## 摊还分析

对一个数据结构执行n个操作
- 有些操作代价高
- 有些操作代价低
- 有些操作代价中等

将所有操作的代价平摊到每个操作上
- 不涉及概率
- 不同于平均情况


### 聚合分析

例子：栈的三种操作
- 对一个空栈，执行由n个PUSH、POP、MULTIPOP组成的操作，代价是多少?

**错误：** 由于multipop(s,n)的代价最坏为n,因此n个操作最坏为 $O(n^2)$

**正确：** 一个元素要么入栈,要么出栈,一个空栈中,n个PUSH, POP, MULTIPOP组成的操作最多与PUSH次数相当 即最多对n个元素操作,因此为 $O(n)$

### 核算方法

一个元素只有入栈后,才能出栈,将代价全部放到PUSH操作上(预支付将来出栈的代价), 出栈操作代价为0, 因此n个操作代价为O(n)

### 势能方法

- 数据结构初始状态 $D_0$，其势为 $\Phi(D_0)$
- 执行第 i 个操作的状态 D_i，其势为 $\Phi(D_i)$
- 第 i 个操作的摊还代价 $\hat{c_i}$，真实代价$c_i$
  $$
  \hat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i-1})
  $$
- 总摊还代价
  $$
  \sum_{i=1}^{n} \hat{c}_i = \sum_{i=1}^{n} \left( c_i + \Phi(D_i) - \Phi(D_{i-1}) \right) \\ 
  = \sum_{i=1}^{n} c_i + \Phi(D_n) - \Phi(D_0)
  $$

### 例子

#### **问题描述**

- **k 位二进制计数器**，初始为 0。
- 每次执行 **+1 操作**，连续加 n 次。
- 每次加 1 时，可能会有若干位从 1 变为 0（**复位**），也可能有一位从 0 变为 1。
- 我们要分析 **n 次加法的摊还代价**。

#### **势能函数**

定义势能为 **当前计数器中 1 的个数**：
**初始势能** $\Phi(D_0) = 0$，因为初始计数器全是 0。


第 i 次加法后，两种情况：

- **结果是全 0**：

$$
\Phi(D_i) - \Phi(D_{i-1}) = -k
$$

- **非全 0**：

$$
\Phi(D_i) - \Phi(D_{i-1}) = 1 - t_i
$$

#### **摊还代价计算**

摊还代价公式：

$$
\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})
$$

带入具体表达式：

$$
\hat{c}_i = (1 + t_i) + (\Phi(D_i) - \Phi(D_{i-1}))
$$


- **情况一：全 0**

$$
\hat{c}_i = (1 + k) + (-k) = 1
$$

- **情况二：非全 0**

$$
\hat{c}_i = (1 + t_i) + (1 - t_i) = 2
$$


#### **结论**

- **摊还代价 ≤ 2**，**每次操作最多消耗 2 单位代价**。
- 因为我们把复位产生的高峰代价通过势能函数均摊到了每次操作。