# 贪心

## 最小生成树

### Kruskal

边权从小到大排序，并查集

## 最短路径

### Dijkstra

给定带权图，边权值 $ \ge 0 $

- 从起点开始
- 分为已经最近/还未最近
- 从已经最近的点集中选点连接到还未最近的点集


### Floyd

动态规划算法，可以求出任意两点间的最短路径。

核心思想：逐步尝试把每个节点作为中间节点，判断是否能通过该中间节点缩短任意两点间的距离。

状态定义：
- `dp[i][j][k]` 表示从点i到点j，只经过编号不超过k的中间点的最短距离
- 最终结果为 `dp[i][j][n]`，表示从i到j可以经过所有点的最短路径

状态转移方程：
$$
dp[i][j][k] = min(dp[i][j][k-1], dp[i][m][k-1] + dp[m][j][k-1])
$$
代码实现（三重循环）：
```cpp
// 初始化邻接矩阵dist，dist[i][j]表示从i到j的直接距离
// 若两点间无边相连，则设为无穷大

// Floyd核心算法
for (int k = 0; k < n; k++) {      // 枚举中间点
    for (int i = 0; i < n; i++) {  // 枚举起点
        for (int j = 0; j < n; j++) {  // 枚举终点
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
}
```

## 活动选择问题

时间轴上有一系列活动，选择最大相容集合。

使用结束时间排序，每次选择最早结束的活动


## 哈夫曼编码

二叉树，叶节点权值 $ w_i $，到根节点的路径为 $ l_i $，则带权路径长度为其乘积求和。

选最小的两个组合，重复。
